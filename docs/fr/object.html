<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Object · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Object · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/bucklescript/index.html"/><meta property="og:description" content="JavaScript objects are used for so many purposes that if we had a single API for typing them, we&#x27;d likely end up with &quot;this is an object that can take potentially many unknown fields with many unknown value types&quot;, which isn&#x27;t very useful."/><link rel="shortcut icon" href="/img/logos/bucklescript_small.svg"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/bucklescript/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/bucklescript/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logos/bucklescript_small.svg"/><h2 class="headerTitle">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/fr/installation.html" target="_self">Docs</a></li><li><a href="/docs/fr/playground.html" target="_self">Try</a></li><li><a href="/docs/fr/community.html" target="_self">Community</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/zh-CN">中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Interop</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/what-why.html">What &amp; Why</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/installation.html">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/new-project.html">New Project</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/concepts-overview.html">Concepts Overview</a></li></ul></div><div class="navGroup navGroupActive"><h3>Interop</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/interop-overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/embed-raw-javascript.html">Embed Raw JavaScript</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/common-data-types.html">Common Data Types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/intro-to-external.html">Intro to External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/boolean.html">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/bind-to-global-values.html">Bind to Global Values</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/null-undefined-option.html">Null, Undefined &amp; Option</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/fr/object.html">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/class.html">Class</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function.html">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/import-export.html">Import &amp; Export</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/regular-expression.html">Regular Expression</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exceptions.html">Exceptions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/generate-converters-accessors.html">Generate Converters &amp; Helpers</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/nodejs-special-variables.html">NodeJS Special Variables</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/interop-misc.html">Miscellaneous</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/typescript-support.html">TypeScript Support</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/browser-support-polyfills.html">Browser Support &amp; Polyfills</a></li></ul></div><div class="navGroup navGroupActive"><h3>Build System</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/build-overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/build-configuration.html">Configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/interop-with-js-build-systems.html">Interop with JS Build System</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/build-performance.html">Performance</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/build-advanced.html">Advanced</a></li></ul></div><div class="navGroup navGroupActive"><h3>Standard Library</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/stdlib-overview.html">Overview</a></li></ul></div><div class="navGroup navGroupActive"><h3>Advanced</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/conditional-compilation.html">Conditional Compilation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extended-compiler-options.html">Extended Compiler Options</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/use-existing-ocaml-libraries.html">Use Existing OCaml Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/difference-from-native-ocaml.html">Difference from Native OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/compiler-architecture-principles.html">Compiler Architecture &amp; Principles</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/comparison-to-jsoo.html">Comparison to Js_of_ocaml</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/bucklescript/fr" target="_blank">Translate</a><h1>Object</h1></header><article><div><span><p>JavaScript objects are used for so many purposes that if we had a single API for typing them, we'd likely end up with &quot;this is an object that can take potentially many unknown fields with many unknown value types&quot;, which isn't very useful.</p>
<p>BS splits the many overloaded usage of JS objects into distinct categories, for better UX and perf.</p>
<h2><a class="anchor" aria-hidden="true" name="object-as-hash-map"></a><a href="#object-as-hash-map" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object as Hash Map</h2>
<p>Up until recently, where JS finally got proper Map support, objects have been used as a map. The characteristics of object-as-map are the following:</p>
<ul>
<li>contains values that are all of the same type</li>
<li>might or might not add/remove arbitrary keys</li>
<li>might or might not be accessed using a dynamic/computed key</li>
</ul>
<p>If these points (especially the first one) describe your object usage, then look no further than using the <a href="https://bucklescript.github.io/bucklescript/api/Js.Dict.html"><code>Js.Dict</code></a> API! This is a thin layer of binding we've made for such situation. Under the hood, a <code>Js.Dict</code> is just an object, and the bindings are compiled away. No performance cost. Actually, <strong>better</strong> than no perf cost! See the Design Decisions below.</p>
<p>In this mode, you can do all the metaprogramming you're used to with JS objects: get all keys through <code>Js.Dict.keys</code>, get values through <code>Js.Dict.values</code>, etc.</p>
<h2><a class="anchor" aria-hidden="true" name="object-as-record"></a><a href="#object-as-record" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object as &quot;Record&quot;</h2>
<p>If your object:</p>
<ul>
<li>has a known number of fields</li>
<li>might or might not contain values of heterogeneous types</li>
</ul>
<p>Then you're really using it like a &quot;record&quot; in most languages. For example, think of the difference of use-case and intent between the object <code>{name: &quot;John&quot;, age: 10, job: &quot;CEO&quot;}</code> and <code>{&quot;John&quot;: 10, &quot;Allison&quot;: 20, &quot;Jimmy&quot;: 15}</code>.</p>
<p>The latter case would be the previous &quot;hash map mode&quot;. The former case would be &quot;record mode&quot;, treated here.</p>
<h3><a class="anchor" aria-hidden="true" name="typing"></a><a href="#typing" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Typing</h3>
<p>Use the type <code>Js.t</code> that wraps an OCaml object type:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt;
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">int</span>;
  job: <span class="hljs-built_in">string</span>
&gt; <span class="hljs-type">Js</span>.t

<span class="hljs-keyword">external</span> john : person = <span class="hljs-string">"john"</span>[@@bs.<span class="hljs-keyword">val</span> ]
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">type person = <span class="hljs-keyword">Js.t({
</span>  .
<span class="hljs-symbol">  name:</span> string,
<span class="hljs-symbol">  age:</span> int,
<span class="hljs-symbol">  job:</span> string
})<span class="hljs-comment">;</span>

[@<span class="hljs-keyword">bs.val] </span><span class="hljs-keyword">external </span><span class="hljs-keyword">john </span>: person = <span class="hljs-string">"john"</span><span class="hljs-comment">;</span>
</code></pre>
<p><strong>From now on</strong>, we'll call the BuckleScript interop object &quot;<code>Js.t</code> object&quot;, to disambiguate it with normal object and JS object.</p>
<p>Because object types are used often, Reason gives it a nicer sugar. <code>Js.t({. name: string})</code> will format to <code>{. &quot;name&quot;: string}</code>.</p>
<h3><a class="anchor" aria-hidden="true" name="accessors"></a><a href="#accessors" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessors</h3>
<h4><a class="anchor" aria-hidden="true" name="read"></a><a href="#read" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Read</h4>
<p>To access a field, use <code>##</code>: <code>let johnName = john##name</code>.</p>
<h4><a class="anchor" aria-hidden="true" name="write"></a><a href="#write" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Write</h4>
<p>To modify a field, you need to first mark a field as mutable. By default, the <code>Js.t</code> object type is immutable.</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt; age : <span class="hljs-built_in">int</span> [@bs.set] &gt; <span class="hljs-type">Js</span>.t
<span class="hljs-keyword">external</span> john: person = <span class="hljs-string">"john"</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> _ = john##age #= <span class="hljs-number">99</span>
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">type person = {. [@<span class="hljs-keyword">bs.set] </span><span class="hljs-string">"age"</span>: int}<span class="hljs-comment">;</span>
[@<span class="hljs-keyword">bs.val] </span><span class="hljs-keyword">external </span><span class="hljs-keyword">john </span>: person = <span class="hljs-string">"john"</span><span class="hljs-comment">;</span>

<span class="hljs-keyword">john##age </span><span class="hljs-comment">#= 99;</span>
</code></pre>
<p><strong>Note</strong>: you can't use dynamic/computed keys in this paradigm.</p>
<h4><a class="anchor" aria-hidden="true" name="call"></a><a href="#call" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Call</h4>
<p>To call a method of a field, mark the function signature as <code>[@bs.meth]</code>:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt; say : <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">unit</span> [@bs.meth] &gt; <span class="hljs-type">Js</span>.t
<span class="hljs-keyword">external</span> john: person = <span class="hljs-string">"john"</span> [@@bs.<span class="hljs-keyword">val</span>]

<span class="hljs-keyword">let</span> _ = john##say <span class="hljs-string">"hey"</span> <span class="hljs-string">"jude"</span>
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">type</span> person = {. [@bs.meth] <span class="hljs-string">"say"</span>: <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>)</span> =&gt;</span> unit};
[@bs.val] external john : person = <span class="hljs-string">"john"</span>;

john##say(<span class="hljs-string">"hey"</span>, <span class="hljs-string">"jude"</span>);
</code></pre>
<p><strong>Why <code>[bs.meth]</code></strong>? Why not just call it directly? A JS object might carry around a reference to <code>this</code>, and infamously, what <code>this</code> points to can change. OCaml/BuckleScript functions are curried by default; this means that if you intentionally curry <code>say</code>, by the time you fully apply it, the <code>this</code> context could be wrong:</p>
<pre><code class="hljs css ocaml"><span class="hljs-comment">(* wrong *)</span>
<span class="hljs-keyword">let</span> talkTo = john##say(<span class="hljs-string">"hey"</span>)

<span class="hljs-keyword">let</span> jude = talkTo <span class="hljs-string">"jude"</span>
<span class="hljs-keyword">let</span> paul = talkTo <span class="hljs-string">"paul"</span>
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* wrong */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">talkTo</span> = john<span class="hljs-comment">##say("hey");</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">jude</span> = talkTo(<span class="hljs-string">"jude"</span>);
<span class="hljs-keyword">let</span> <span class="hljs-attr">paul</span> = talkTo(<span class="hljs-string">"paul"</span>);
</code></pre>
<p>To ensure that folks don't accidentally curry a JavaScript method, we track every method call using <code>##</code> to make sure it's fully applied <em>immediately</em>. Under the hood, we effectively turn a function-looking call into a special <code>bs.meth</code> call (it only <em>looks</em> like a function). Annotating the type definition of <code>say</code> with <code>bs.meth</code> completes this check.</p>
<h3><a class="anchor" aria-hidden="true" name="creation"></a><a href="#creation" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation</h3>
<p>You can use <code>[%bs.obj putAnOCamlRecordHere]</code> DSL to create a JS object:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> bucklescript = [%bs.obj {
  info = {author = <span class="hljs-string">"Bob"</span>}
}]

<span class="hljs-keyword">let</span> name = bucklescript##info##author
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> bucklescript = [%bs.obj {
  info: {author: <span class="hljs-string">"Bob"</span>}
}];

<span class="hljs-keyword">let</span> name = bucklescript##info##author;
</code></pre>
<p>Because object values are used often, Reason gives it a nicer sugar. <code>[%bs.obj {foo: 1}]</code> will format to <code>{. &quot;foo&quot;: 1}</code>.</p>
<p>The created object will have an inferred type, no type declaration needed! The above example will infer as <code>&lt; info: &lt; author: string &gt; Js.t &gt; Js.t</code>. Reason syntax: <code>{. &quot;info&quot;: {. &quot;author&quot;: string}}</code>.</p>
<p><strong>Note</strong>: since the value has its type inferred, <strong>don't</strong> accidentally do this:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> person = &lt;age: <span class="hljs-built_in">string</span>&gt; <span class="hljs-type">Js</span>.t
<span class="hljs-keyword">let</span> jane = [%bs.obj {age = <span class="hljs-string">"hi"</span>}]
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">type person</span> = {. <span class="hljs-string">"age"</span>: string};
<span class="hljs-attribute">let jane</span> = {<span class="hljs-string">"age"</span>: <span class="hljs-string">"hi"</span>};
</code></pre>
<p>See what went wrong here? We've declared a <code>person</code> type, but <code>jane</code> is inferred as its own type, so <code>person</code> is ignored and no error happens! To give <code>jane</code> an explicit type, simply annotate it: <code>let jane: person = ...</code>. This will then error correctly.</p>
<h4><a class="anchor" aria-hidden="true" name="special-creation-function"></a><a href="#special-creation-function" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Special Creation Function</h4>
<p>OCaml's optional labeled function maps rather nicely to a JS object creation. We provide an alternative way of creating objects, <code>bs.obj</code>, that is convenient if said object contains optional fields:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> makeConfig : high:<span class="hljs-built_in">int</span> -&gt; ?low:<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">unit</span> -&gt; _ = <span class="hljs-string">""</span> [@@bs.obj]

<span class="hljs-keyword">let</span> c1 = makeConfig ~high:<span class="hljs-number">3</span> <span class="hljs-literal">()</span>
<span class="hljs-keyword">let</span> c2 = makeConfig ~low:<span class="hljs-number">2</span> ~high:<span class="hljs-number">3</span> <span class="hljs-literal">()</span>

<span class="hljs-comment">(* access them as Js.t objects! *)</span>
<span class="hljs-keyword">let</span> high: <span class="hljs-built_in">int</span> = c1##high
<span class="hljs-keyword">let</span> low: <span class="hljs-built_in">int</span> <span class="hljs-type">Js</span>.undefined = c1##low
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">[@bs.obj] external makeConfig : (~high: int, ~low: <span class="hljs-attr">int=?,</span> unit) =&gt; <span class="hljs-attr">_</span> = <span class="hljs-string">""</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">c1</span> = makeConfig(~<span class="hljs-attr">high=3,</span> ());
<span class="hljs-keyword">let</span> <span class="hljs-attr">c2</span> = makeConfig(~<span class="hljs-attr">low=2,</span> ~<span class="hljs-attr">high=3,</span> ());

<span class="hljs-comment">/* access them as Js.t objects! */</span>
<span class="hljs-keyword">let</span> high: <span class="hljs-attr">int</span> = c1<span class="hljs-comment">##high;</span>
<span class="hljs-keyword">let</span> low: Js.undefined(int) = c1<span class="hljs-comment">##low;</span>
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> c1 = {<span class="hljs-attr">high</span>: <span class="hljs-number">3</span>};
<span class="hljs-keyword">var</span> c2 = {<span class="hljs-attr">high</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">low</span>: <span class="hljs-number">2</span>};
<span class="hljs-keyword">var</span> high = c1.high;
<span class="hljs-keyword">var</span> low = c1.low;
</code></pre>
<p><strong>Note</strong>:</p>
<ul>
<li><p>Marking the return value as <code>_</code> will infer a <code>Js.t</code> object of the expected shape!</p></li>
<li><p>The final <code>unit</code> is there to indicate that you've finished applying optional arguments. More info <a href="https://reasonml.github.io/guide/language/function#optional-labeled-arguments">here</a>.</p></li>
</ul>
<p>You can also attach constant data unto an object using <code>[@bs.as]</code>:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">external</span> makeIOConfig :
  stdio:(_ [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"inherit"</span>]) -&gt;
  cwd:<span class="hljs-built_in">string</span> -&gt;
  detached:(_ [@bs.<span class="hljs-keyword">as</span> {json|<span class="hljs-literal">true</span>|json}]) -&gt;
  <span class="hljs-built_in">unit</span> -&gt;
  _ = <span class="hljs-string">""</span> [@@bs.obj]

<span class="hljs-keyword">let</span> config = makeIOConfig ~cwd:<span class="hljs-string">"."</span> <span class="hljs-literal">()</span>
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">[@bs.obj]
external makeIOConfig : (
  ~stdio: [@bs.as <span class="hljs-string">"inherit"</span>] _,
  ~cwd: string,
  ~detached: [@bs.as {json|<span class="hljs-literal">true</span>|json}] _,
  unit
) =&gt; _ = <span class="hljs-string">""</span>;

let<span class="hljs-built_in"> config </span>= makeIOConfig(~<span class="hljs-attribute">cwd</span>=<span class="hljs-string">"."</span>, ());
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> config = {
  <span class="hljs-attr">stdio</span>: <span class="hljs-string">"inherit"</span>,
  <span class="hljs-attr">cwd</span>: <span class="hljs-string">"."</span>,
  <span class="hljs-attr">detached</span>: <span class="hljs-literal">true</span>
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="invalid-field-names"></a><a href="#invalid-field-names" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invalid Field Names</h3>
<p>Sometimes, you might be binding to JavaScript object fields that start with capital letters or use reserved words. The latter is invalid and the former is reserved for module and variant names. To circumvent this, we support object label mangling/translation:</p>
<pre><code class="hljs css ocaml">stream##_open
stream##_MAX_LENGTH
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js">stream.open;
stream.MAX_LENGTH;
</code></pre>
<p><strong>Double check your JS output</strong> to make sure your name mangling worked.</p>
<p>If your key contains hyphens... you'll have to use the next method.</p>
<!-- TODO: playground link -->
<h3><a class="anchor" aria-hidden="true" name="js-object-ocaml-record-conversion"></a><a href="#js-object-ocaml-record-conversion" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Js Object &lt;-&gt; OCaml Record conversion</h3>
<p>If you don't want to work with <code>Js.t</code> objects and want to use idiomatic OCaml/Reason records, we provide automatic generation of helpers that convert between a <code>Js.t</code> object and a corresponding record type. See the section on <a href="generate-helpers-deriving.md">Generate Helpers (Deriving)</a>.</p>
<h2><a class="anchor" aria-hidden="true" name="object-as-dynamic-record"></a><a href="#object-as-dynamic-record" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object as Dynamic Record</h2>
<p>When The two above modes of binding to objects fail, you can always fall back to this one. And sometimes this the <strong>preferable</strong> way of binding to objects, because it:</p>
<ul>
<li>deals with objects with potentially arbitrary shapes</li>
<li>allows heterogeneous values</li>
<li>allows hyphen in object keys</li>
</ul>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> t
<span class="hljs-keyword">external</span> create : <span class="hljs-built_in">int</span> -&gt; t = <span class="hljs-string">"Int32Array"</span> [@@bs.<span class="hljs-keyword">new</span>] <span class="hljs-comment">(* bs.new is documented in the class section *)</span>
<span class="hljs-keyword">external</span> get : t -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">""</span> [@@bs.get_index]
<span class="hljs-keyword">external</span> set : t -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span> [@@bs.set_index]

<span class="hljs-keyword">let</span> i32arr = (create <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> _ = set i32arr <span class="hljs-number">0</span> <span class="hljs-number">42</span>
<span class="hljs-keyword">let</span> _ = <span class="hljs-type">Js</span>.log (get i32arr <span class="hljs-number">0</span>)
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">type t;
[<span class="hljs-meta">@bs</span>.<span class="hljs-keyword">new</span>] <span class="hljs-keyword">external</span> create : <span class="hljs-built_in">int</span> =&gt; t = <span class="hljs-string">"Int32Array"</span>; <span class="hljs-comment">/* bs.new is documented in the class section */</span>
[<span class="hljs-meta">@bs</span>.get_index] <span class="hljs-keyword">external</span> <span class="hljs-keyword">get</span> : (t, <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">""</span>;
[<span class="hljs-meta">@bs</span>.set_index] <span class="hljs-keyword">external</span> <span class="hljs-keyword">set</span> : (t, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) =&gt; unit = <span class="hljs-string">""</span>;

let i32arr = create(<span class="hljs-number">3</span>);
<span class="hljs-keyword">set</span>(i32arr, <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);
Js.log(<span class="hljs-keyword">get</span>(i32arr, <span class="hljs-number">0</span>));
</code></pre>
<p>Albeit the names are called <code>get_index</code> and <code>set_index</code>, it's really dynamic access of objects fields and/or arrays.</p>
<p>Output:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">var</span> i32arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(<span class="hljs-number">3</span>);
i32arr[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;
<span class="hljs-built_in">console</span>.log(i32arr[<span class="hljs-number">0</span>]);
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="specific-getter-setter"></a><a href="#specific-getter-setter" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Specific Getter/Setter</h3>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> textarea
<span class="hljs-keyword">external</span> setName : textarea -&gt; <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"name"</span> [@@bs.set]
<span class="hljs-keyword">external</span> getName : textarea -&gt; <span class="hljs-built_in">string</span> = <span class="hljs-string">"name"</span> [@@bs.get]

<span class="hljs-keyword">external</span> myTextArea: textarea = <span class="hljs-string">""</span> [@@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">let</span> _ = setName myTextArea <span class="hljs-string">"asd"</span>
</code></pre>
<p>Reason syntax:</p>
<pre><code class="hljs css reason">type textarea<span class="hljs-comment">;</span>
[@<span class="hljs-keyword">bs.set] </span><span class="hljs-keyword">external </span>setName : (textarea, string) =&gt; unit = <span class="hljs-string">"name"</span><span class="hljs-comment">;</span>
[@<span class="hljs-keyword">bs.get] </span><span class="hljs-keyword">external </span>getName : textarea =&gt; string = <span class="hljs-string">"name"</span><span class="hljs-comment">;</span>

[@<span class="hljs-keyword">bs.val] </span><span class="hljs-keyword">external </span>myTextArea : textarea = <span class="hljs-string">""</span><span class="hljs-comment">;</span>
setName(myTextArea, <span class="hljs-string">"asd"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Output:</p>
<pre><code class="hljs css js">myTextArea.name = <span class="hljs-string">"asd"</span>;
</code></pre>
<p>There's also a trick with object methods and method chaining in the next function section.</p>
<h2><a class="anchor" aria-hidden="true" name="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>All these tricks to bind to JS objects might be overwhelming; don't worry, you can just pick whatever you need as you go. But hopefully you can see that there's almost always a way to bind to your favorite JS library with no cost!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="null-undefined-option.html">← Null, Undefined &amp; Option</a><a class="docs-next button" href="class.html">Class →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react'
              });
            </script></body></html>